title: Brief Intro to Django and Machine Learning
---
author: Aleph Melo
---
pub_date: 2016-09-09
---
summary:

Learn how to quickly setup a Django project using a very lightweight file and how to use a backend service to respond requests from users using a dead simple machine learning classifier project. 
---
body:
# Editorial
This article aims to provide a quick start on how to setup and understand the basics premises about the Django framework, to give you a glimpse about how things work under the hood, and a bonus feature is that we are going to build a simple machine learning feature using a classifier, one of the basics concepts of machine learning, this way in our toy example it might help you understand how a backend service interacts with the client.

# Requirements
Some Python coding is always welcome, but even if you don’t have Python background but have some programming in general you should be fine too, since Python syntax is very clear and concise. Libraries that we need in order to follow this article:

* Numpy
* Django
* Scikit-learn

# What is Django Anyway?
Django is a high-level Python Web framework that encourages rapid development and clean, pragmatic design. Built by experienced developers, it takes care of much of the hassle of Web development, so you can focus on writing your app without needing to reinvent the wheel. It’s free and open source.

In a nutshell, Django takes care of all HTTP requests sent from clients using your app and handle the HTTP responses, that’s it. What to do and how to treat the data in the middle of this process is totally up to you, my dearest. This is what freedom looks like!

The framework already comes with tons of great features that we can use, like: built-in ORM (Object-Relational Mapper), powerful url dispatcher, several forms of validation, built-in template system, l10n (internationalization), cache system, auth handlers, web server for dev, awesome admin interface and so on.

# Cool! How Does it Work?
For us to begin understanding how Django works first we need to understand a very common Design Pattern in web development that is called `MVC` which stands for `Model-View-Controller`. Its concepts are very simple and intuitive. The `Model` takes care of data, where your data structure will be defined. The `View` contains the elements in the user interface. The `Controller` is the bridge between the model and the view. All good so far? Great. 

But hold your horses that’s not how it works yet. Django uses a similar version of this design pattern called `MVT` which stands for `Model-View-Template`. Whereas the `Model` is the same as in `MVC`. The `View` now defines what and how data should be represented and always return an `HTTP Response`. The `Template` renders the data itself in the format you might want (HTML, PDF, XHTML, etc).

Let's take a closer look on how long a request lives and the paths it may take in life.

## Request Lifecycle
In the image above we see clearly the path that request sent by a client might take during its life. 

Let’s say a client enters at `www.example.com/index`, in Django the following might happen: the request comes to the URL dispatcher that it’s liked with a `Python` function (`View`), if the request needs something from the database (`Model`), the function would go there retrieve what it needs to be retrieved and finally the response would be returned to the user via `Template` a.k.a. frontend stuff like HTML. I hope this gets clearer when we got to the practical details.  
<div class="post-image"><img src="django-arch.png"></div>

# 
---

tags:

python
data-science
dev
---
twitter_handle: Alephbreno
